<?php
/**
 * Fresh Comments
 *
 * For those who really miss Brian’s Latest Comments. :)
 * Usage: <?php $theme->freshcomments(); ?>
 **/

class FreshComments extends Plugin
{
	private $config = array();
	private $class_name = '';
	private $cache_name = '';
	private $default_options = array(
		'num_posts' => 5,
		'num_comments' => 6,
		'show_trackbacks' => FALSE,
		'show_pingbacks' => FALSE,
		'fade_old' => TRUE,
		'range_in_days' => 10,
		'newest_color' => '#444444',
		'oldest_color' => '#cccccc'
	);

	/**
	 * Required plugin information
	 * @return array The array of information
	 **/
	public function info()
	{
		return array(
			'name' => 'Fresh Comments',
			'version' => '0.3-pre',
			'url' => 'http://code.google.com/p/bcse/wiki/FreshComments',
			'author' => 'Joel Lee',
			'authorurl' => 'http://blog.bcse.info/',
			'license' => 'Apache License 2.0',
			'description' => 'Allow you display recent comments just like Brian’s latest Comment.',
			'copyright' => '2008'
		);
	}

	/**
	 * Add update beacon support
	 **/
	public function action_update_check()
	{
	 	Update::add('Fresh Comments', '5f5f68a0-fc19-47c2-969f-25dcc9959f7d', $this->info->version);
	}

	/**
	 * Add actions to the plugin page for this plugin
	 * @param array $actions An array of actions that apply to this plugin
	 * @param string $plugin_id The string id of a plugin, generated by the system
	 * @return array The array of actions to attach to the specified $plugin_id
	 **/
	public function filter_plugin_config($actions, $plugin_id)
	{
		if ($plugin_id == $this->plugin_id()) {
			$actions[] = _t('Configure', $this->class_name);
		}

		return $actions;
	}

	/**
	 * Respond to the user selecting an action on the plugin page
	 * @param string $plugin_id The string id of the acted-upon plugin
	 * @param string $action The action string supplied via the filter_plugin_config hook
	 **/
	public function action_plugin_ui($plugin_id, $action)
	{
		if ($plugin_id == $this->plugin_id()) {
			switch ($action) {
				case _t('Configure', $this->class_name) :
					$ui = new FormUI(strtolower(get_class($this)));

					$ui->append('fieldset', 'general', _t('General', $this->class_name));

					$ui->general->append('text', 'num_posts', 'option:' . $this->class_name . '__num_posts', _t('&#8470; of Posts', $this->class_name));
					$ui->general->num_posts->add_validator(array($this, 'validate_uint'));
					$ui->general->num_posts->add_validator('validate_required');

					$ui->general->append('text', 'num_comments', 'option:' . $this->class_name . '__num_comments', _t('&#8470; of Comments', $this->class_name));
					$ui->general->num_comments->add_validator(array($this, 'validate_uint'));
					$ui->general->num_comments->add_validator('validate_required');

					$ui->general->append('checkbox', 'show_trackbacks', 'option:' . $this->class_name . '__show_trackbacks', _t('Show Trackbacks', $this->class_name));

					$ui->general->append('checkbox', 'show_pingbacks', 'option:' . $this->class_name . '__show_pingbacks', _t('Show Pingbacks', $this->class_name));

					$ui->append('fieldset', 'fade', _t('Fade-out', $this->class_name));

					$ui->fade->append('checkbox', 'fade_old', 'option:' . $this->class_name . '__fade_old', _t('Fade-out Older Comment', $this->class_name));

					$ui->fade->append('text', 'range_in_days', 'option:' . $this->class_name . '__range_in_days', _t('Fading Speed (bigger is slower)', $this->class_name));
					$ui->fade->range_in_days->add_validator(array($this, 'validate_uint'));
					$ui->fade->range_in_days->add_validator('validate_required');

					$ui->fade->append('text', 'newest_color', 'option:' . $this->class_name . '__newest_color', _t('Newest Color', $this->class_name));
					$ui->fade->newest_color->add_validator(array($this, 'validate_color'));
					$ui->fade->newest_color->add_validator('validate_required');

					$ui->fade->append('text', 'oldest_color', 'option:' . $this->class_name . '__oldest_color', _t('Oldest Color', $this->class_name));
					$ui->fade->oldest_color->add_validator(array($this, 'validate_color'));
					$ui->fade->oldest_color->add_validator('validate_required');

					$ui->append('submit', 'save', _t('Save', $this->class_name));
					$ui->set_option('success_message', _t('Options saved', $this->class_name));
					$ui->out();
					break;
			}
		}
	}

	public function validate_uint($value)
	{
		if (!ctype_digit($value) || strstr($value, '.') || $value < 0) {
			return array(_t('This field must be positive integer.', $this->class_name));
		}
		return array();
	}

	public function validate_color($value)
	{
		if (!preg_match('/^#[0-9a-z]{6}$/i', $value)) {
			return array(_t('This field must be an HTML color hex code.', $this->class_name));
		}
		return array();
	}

	/**
	 * Returns true if plugin config form values defined in action_plugin_ui should be stored in options by Habari
	 * @return bool True if options should be stored
	 **/
	public function updated_config($ui)
	{
		return true;
	}

	/**
	 * Return the HTML of Fresh Comments
	 * @param Theme $theme The theme that will display the template
	 **/
	public function theme_freshcomments($theme)
	{
		if (Cache::has($this->cache_name)) {
			return Cache::get($this->cache_name);
		} else {
			$comment_types = array(Comment::COMMENT);
			if ($this->config['show_trackbacks']) $comment_types[] = Comment::TRACKBACK;
			if ($this->config['show_pingbacks']) $comment_types[] = Comment::PINGBACK;

			$query = 'SELECT {posts}.* FROM {comments}, {posts} WHERE {posts}.status = ? AND {comments}.status = ? AND ({comments}.type = ?' . str_repeat(' OR {comments}.type = ?', count($comment_types) - 1) . ') AND {posts}.id = post_id GROUP BY post_id ORDER BY {comments}.date DESC, post_id DESC LIMIT ' . $this->config['num_posts'];
			$query_args = array_merge(array(Post::status('published'), Comment::STATUS_APPROVED), $comment_types);
			$commented_posts = DB::get_results($query, $query_args, 'Post');

			$freshcomments = array();
			foreach ($commented_posts as $i => $post) {
				$query = 'SELECT * FROM {comments} WHERE post_id = ? AND status = ? AND (type = ?' . str_repeat(' OR type = ?', count($comment_types) - 1) . ') ORDER BY date DESC LIMIT ' . $this->config['num_comments'];
				$query_args = array_merge(array($post->id, Comment::STATUS_APPROVED), $comment_types);
				$comments = DB::get_results($query, $query_args, 'Comment');

				$freshcomments[$i]['post'] = $post;
				foreach ($comments as $j => $comment) {
					$freshcomments[$i]['comments'][$j]['comment'] = $comment;
					$freshcomments[$i]['comments'][$j]['color'] = $this->get_color($comment->date);
				}
			}

			$theme->freshcomments = $freshcomments;
			$html = $theme->fetch('freshcomments');
			Cache::set($this->cache_name, $html, 3600);
			return $html;
		}
	}

	protected static function sanitize_color($new_color)
	{
		return round(max(0, min(255, $new_color)));
	}

	protected function get_color($comment_date)
	{
		if ($this->config['fade_old']) {
			$time_span = ($_SERVER['REQUEST_TIME'] - $comment_date->int) / $this->config['range_in_seconds'];
			$time_span = min($time_span, 1);
			$color = array(
				'r' => self::sanitize_color($this->config['newest_color']['r'] + $this->config['color_range']['r'] * $time_span),
				'g' => self::sanitize_color($this->config['newest_color']['g'] + $this->config['color_range']['g'] * $time_span),
				'b' => self::sanitize_color($this->config['newest_color']['b'] + $this->config['color_range']['b'] * $time_span)
			);
			return '#' . ColorUtils::rgb_hex($color);
		} else {
			return $this->config['newest_color'];
		}
	}

	/**
	 * On plugin activation, set the default options
	 */
	public function action_plugin_activation($file)
	{
		if (realpath($file) == __FILE__) {
			$this->class_name = strtolower(get_class($this));
			$this->cache_name = Site::get_url('host') . $this->class_name;
			foreach ($this->default_options as $name => $value) {
				$current_value = Options::get($this->class_name . '__' . $name);
				if (is_null($current_value)) {
					Options::set($this->class_name . '__' . $name, $value);
				}
			}
		}
	}

	/**
	 * On plugin deactivation, expire the cache
	 */
	public function action_plugin_deactivation($file)
	{
		if (realpath($file) == __FILE__) {
			Cache::expire($this->cache_name);
		}
	}

	/**
	 * After a new and approved comment is inserted, expire the cache
	 */
	public function action_comment_insert_after($comment)
	{
		if ($comment->status === COMMENT::STATUS_APPROVED) {
			Cache::expire($this->cache_name);
		}
	}

	/**
	 * After an approved comment is updated, expire the cache
	 */
	public function action_comment_update_after($comment)
	{
		if ($comment->status === COMMENT::STATUS_APPROVED) {
			Cache::expire($this->cache_name);
		}
	}

	/**
	 * After an approved comment is deleted, expire the cache
	 */
	public function action_comment_delete_after($comment)
	{
		if ($comment->status === COMMENT::STATUS_APPROVED) {
			Cache::expire($this->cache_name);
		}
	}

	/**
	 * On plugin init, add the template included with this plugin to the available templates in the theme
	 */
	public function action_init()
	{
		$this->class_name = strtolower(get_class($this));
		$this->cache_name = Site::get_url('host') . $this->class_name;
		foreach ($this->default_options as $name => $value) {
			$this->config[$name] = Options::get($this->class_name . '__' . $name);
		}

		// Calculate colors
		if ($this->config['fade_old']) {
			$this->config['range_in_seconds'] = $this->config['range_in_days'] * 24 * 60 * 60 ; 
			$this->config['newest_color'] = ColorUtils::hex_rgb($this->config['newest_color']);
			$this->config['oldest_color'] = ColorUtils::hex_rgb($this->config['oldest_color']);
			$this->config['color_range'] = array(
				'r' => $this->config['oldest_color']['r'] - $this->config['newest_color']['r'],
				'g' => $this->config['oldest_color']['g'] - $this->config['newest_color']['g'],
				'b' => $this->config['oldest_color']['b'] - $this->config['newest_color']['b']
			);
		}

		$this->load_text_domain($this->class_name);
		$this->add_template('freshcomments', dirname(__FILE__) . '/freshcomments.php');
	}
}
?>
